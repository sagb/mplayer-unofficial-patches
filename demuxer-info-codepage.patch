diff -u3 -r mplayer-svn/cfg-common.h mplayer-patched/cfg-common.h
--- mplayer-svn/cfg-common.h	2016-06-29 11:55:24.931894913 +0300
+++ mplayer-patched/cfg-common.h	2016-06-29 11:51:20.247593879 +0300
@@ -465,6 +465,9 @@
 #ifdef CONFIG_DVBIN
     {"dvbin", dvbin_opts_conf, CONF_TYPE_SUBCONFIG, 0, 0, 0, NULL},
 #endif
+#ifdef CONFIG_ICONV
+    { "demuxcp", &demuxcp, CONF_TYPE_STRING, 0, 0, 0, NULL },
+#endif
 
 // ------------------------- a-v sync options --------------------
 
diff -u3 -r mplayer-svn/DOCS/man/en/mplayer.1 mplayer-patched/DOCS/man/en/mplayer.1
--- mplayer-svn/DOCS/man/en/mplayer.1	2016-06-29 11:55:24.891894862 +0300
+++ mplayer-patched/DOCS/man/en/mplayer.1	2016-06-29 11:50:49.495556045 +0300
@@ -1618,6 +1618,36 @@
 use this option for encoding without testing it first.
 .
 .TP
+.B \-demuxcp <codepage> (iconv only)
+If your system supports iconv(3), you can use this option to
+specify the codepage of demuxer information messages. 
+This option is useful for displaying MP3 ID tags which codepage
+is different from mplayer codepage (see \-codepage).
+.sp 1
+.I EXAMPLE:
+.PD 0
+.RSs
+\-demuxcp latin2
+.br
+\-demuxcp cp1251
+.RE
+.PD 1
+.
+.TP
+.B \-demuxcp enca:<language>:<fallback codepage> (ENCA only)
+You can specify demuxer information language using a two letter 
+language code to make ENCA detect the codepage automatically.
+Fallback codepage specifies the codepage to use, when autodetection fails.
+.sp 1
+.I EXAMPLE:
+.PD 0
+.RSs
+.IPs "\-demuxcp enca:ru:cp1251"
+Guess the MP3 tags encoding for Russian, fall back on cp1251.
+.RE
+.PD 1
+.
+.TP
 .B \-demuxer <[+]name>
 Force demuxer type.
 Use a '+' before the name to force it, this will skip some checks!
diff -u3 -r mplayer-svn/DOCS/man/ru/mplayer.1 mplayer-patched/DOCS/man/ru/mplayer.1
--- mplayer-svn/DOCS/man/ru/mplayer.1	2016-06-29 11:55:24.803894755 +0300
+++ mplayer-patched/DOCS/man/ru/mplayer.1	2016-06-29 11:50:56.183564274 +0300
@@ -1299,6 +1299,37 @@
 не используйте эту опцию при кодировании без предварительного тестирования.
 .
 .TP
+.B \-demuxcp <кодовая страница> (только iconv)
+Если ваша система поддерживает iconv(3), вы можете использовать эту опцию
+для указания кодовой страницы информационных сообщений демультиплексора.
+Эта опция полезна для отображения MP3 ID тэгов, кодировка которых 
+отличается от кодировки mplayer (см. \-codepage).
+.sp 1
+.I ПРИМЕР:
+.PD 0
+.RSs
+\-demuxcp latin2
+.br
+\-demuxcp cp1251
+.RE
+.PD 1
+.
+.TP
+.B \-demuxcp enca:<язык>:<кодовая страница по умолчанию> (только ENCA)
+Вы можете указать язык информационных сообщений демультиплексора, используя 
+двухбуквенный языковой код, чтобы ENCA определил кодовую страницу автоматически.
+Когда автоопределение не срабатывает, используется кодовая страница по умолчанию.
+.sp 1
+.I ПРИМЕР:
+.PD 0
+.RSs
+.IPs "\-demuxcp enca:ru:cp1251"
+Автоматически определить кодировку MP3 тэгов для русского языка, 
+иначе использовать cp1251.
+.RE
+.PD 1
+.
+.TP
 .B \-demuxer <[+]название>
 Устанавливает тип демультиплексора.
 Используйте '+' перед названием для принудительной  установки, это пропустит некоторые проверки!
diff -u3 -r mplayer-svn/libmpdemux/demuxer.c mplayer-patched/libmpdemux/demuxer.c
--- mplayer-svn/libmpdemux/demuxer.c	2016-06-29 11:55:24.731894668 +0300
+++ mplayer-patched/libmpdemux/demuxer.c	2016-06-29 11:51:42.595621373 +0300
@@ -62,6 +62,14 @@
 int rtsp_transport_tcp = 0;
 int rtsp_transport_sctp = 0;
 
+#ifdef CONFIG_ICONV
+#include <iconv.h>
+#endif
+
+#ifdef CONFIG_ENCA
+#include <enca.h>
+#endif
+
 // This is quite experimental, in particular it will mess up the pts values
 // in the queue - on the other hand it might fix some issues like generating
 // broken files with mencoder and stream copy.
@@ -1421,30 +1429,116 @@
     return 1;
 }
 
+#ifdef CONFIG_ICONV
+char *demuxcp = NULL; // parameter from -demuxcp
+#endif
+
 int demux_info_add(demuxer_t *demuxer, const char *opt, const char *param)
 {
     char **info = demuxer->info;
     int n = 0;
+    char *param_recoded;
+
+#ifdef CONFIG_ICONV
+    iconv_t icdsc = (iconv_t)(-1);
+    const char *fromcp = NULL;
+    const char *tocp = mp_msg_charset ? mp_msg_charset : "UTF-8";
+    size_t ileft, oleft;
+    char *op, *ip, *ot;
+
+#ifdef CONFIG_ENCA
+    char enca_lang[3], enca_fallback[100];
+    const char **languages;
+    size_t langcnt;
+    EncaAnalyser analyser;
+    EncaEncoding encoding;
+    int cur_lang;
+    const char *guessed_cp=NULL;
+#endif
+
+    if (demuxcp) {
+        fromcp = demuxcp;
+#ifdef CONFIG_ENCA
+        if (sscanf(demuxcp, "enca:%2s:%99s", enca_lang, enca_fallback) == 2
+         || sscanf(demuxcp, "ENCA:%2s:%99s", enca_lang, enca_fallback) == 2) {
+            // guessing param codepage
+            languages = enca_get_languages(&langcnt);
+            for (cur_lang = 0; cur_lang < langcnt; cur_lang++) {
+                if (strcasecmp(languages[cur_lang], enca_lang) != 0)
+                    continue;
+                analyser = enca_analyser_alloc(languages[cur_lang]);
+                encoding = enca_analyse_const(analyser, param, strlen(param));
+                enca_analyser_free(analyser);
+                if (encoding.charset != ENCA_CS_UNKNOWN) {
+                    guessed_cp = enca_charset_name(encoding.charset, ENCA_NAME_STYLE_ICONV);
+                    break;
+                }
+            }
+            free(languages);
+            if (guessed_cp)
+                fromcp = guessed_cp;
+            else
+                fromcp = enca_fallback;
+        }
+#endif
+        mp_msg(MSGT_DEMUX,MSGL_V,"Recoding demuxer info value from %s to %s\n", fromcp, tocp);
+        if ((icdsc = iconv_open (tocp, fromcp)) == (iconv_t)(-1)){
+            mp_msg(MSGT_DEMUX,MSGL_ERR,"Error opening iconv descriptor.\n");
+            return 0;
+        }
+        // recoding param to param_recoded
+        ip = (char*)param;
+        ileft = strlen(ip);
+        oleft = 4 * ileft;
+        if (!(ot = malloc(oleft + 1))){
+            mp_msg(MSGT_DEMUXER,MSGL_WARN,"Error allocating mem.\n");
+            return 0;
+        }
+        op = ot;
+        if (iconv(icdsc, &ip, &ileft, &op, &oleft) == (size_t)(-1)) {
+            mp_msg(MSGT_DEMUXER,MSGL_WARN,"Error recoding line.\n");
+            free(ot);
+            return 0;
+        }
+        if (iconv(icdsc, NULL, NULL, &op, &oleft) == (size_t)(-1)) {
+            mp_msg(MSGT_DEMUXER,MSGL_WARN,"Error recoding line, can't clear encoding state.\n");
+        }
+        *op='\0' ;
+        param_recoded = ot;
+        if (icdsc != (iconv_t)(-1)){
+            (void) iconv_close (icdsc);
+            icdsc = (iconv_t)(-1);
+        }
 
+    } else { // no demuxcp option
+        param_recoded = strdup(param);
+    }
+
+#else  // no iconv
+    param_recoded = strdup(param);
+#endif
 
     for (n = 0; info && info[2 * n] != NULL; n++) {
         if (!strcasecmp(opt, info[2 * n])) {
-            if (!strcmp(param, info[2 * n + 1])) {
-                mp_msg(MSGT_DEMUX, MSGL_V, "Demuxer info %s set to unchanged value %s\n", opt, param);
+            if (!strcmp(param_recoded, info[2 * n + 1])) {
+                mp_msg(MSGT_DEMUX, MSGL_V, "Demuxer info %s set to unchanged value %s\n", opt, param_recoded);
+                free(param_recoded);
                 return 0;
             }
             mp_msg(MSGT_DEMUX, MSGL_INFO, MSGTR_DemuxerInfoChanged, opt,
-                   param);
+                   param_recoded);
             free(info[2 * n + 1]);
-            info[2 * n + 1] = strdup(param);
+            info[2 * n + 1] = strdup(param_recoded);
+            free(param_recoded);
             return 0;
         }
     }
 
     info = demuxer->info = realloc(info, (2 * (n + 2)) * sizeof(char *));
     info[2 * n] = strdup(opt);
-    info[2 * n + 1] = strdup(param);
+    info[2 * n + 1] = strdup(param_recoded);
     memset(&info[2 * (n + 1)], 0, 2 * sizeof(char *));
+    free(param_recoded);
 
     return 1;
 }
diff -u3 -r mplayer-svn/libmpdemux/demuxer.h mplayer-patched/libmpdemux/demuxer.h
--- mplayer-svn/libmpdemux/demuxer.h	2016-06-29 11:55:24.747894687 +0300
+++ mplayer-patched/libmpdemux/demuxer.h	2016-06-29 11:51:42.595621373 +0300
@@ -186,6 +186,7 @@
 extern char *audio_demuxer_name;
 extern char *sub_demuxer_name;
 extern char *sub_stream;
+extern char *demuxcp;
 
 extern int rtsp_port;
 extern int rtsp_transport_http;
